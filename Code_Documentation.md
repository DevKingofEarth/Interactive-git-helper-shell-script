# **REPO-CRAFTER CODE DOCUMENTATION**


<!--
Code Documentation for repo-crafter
Copyright (C) 2026 Dharrun Singh .M
SPDX-License-Identifier: CC-BY-SA-4.0
This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.
To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0/.
-->

**Architecture**: Single-file bash script with external config
**Entry Point**: `main()` → `main_menu()` loop

---

## **1. HEADER & SAFETY FLAGS (Lines 1-3)**

```bash
#!/usr/bin/env bash
set -euo pipefail
```

**Purpose**:
- `#!/usr/bin/env bash`: Portable shebang for bash execution
- `set -euo pipefail`: **Critical safety trio**
  - `-e`: Exit immediately on any command failure
  - `-u`: Exit on undefined variable (prevents silent errors)
  - `-o pipefail`: Pipe failures propagate (catches errors in pipelines)

**Debug Impact**: If script exits unexpectedly, check which of these flags triggered.

---

## **2. CONFIGURATION & GLOBALS (Lines 5-25)**

```bash
FORBIDDEN_DIRS=("/etc" "/etc/nixos" "/root" "/bin" "/sbin" "/usr")
LOCAL_ROOT="$HOME/Projects/Local_Projects"
REMOTE_ROOT="$HOME/Projects/Remote_Projects"
COLORS...
```

**Key Variables**:
- `FORBIDDEN_DIRS`: Hardcoded blacklist of system directories. **Never modify this unless you understand the risk**. The `is_safe_directory()` function checks against this.
- `LOCAL_ROOT`: Where unbound projects live. **Changing this requires manually moving existing projects**.
- `REMOTE_ROOT`: Where bound projects live. **Subdirectory structure is generated by platforms.conf**.

**Color Constants**: Used throughout for UX. If colors appear broken, check terminal supports ANSI.

---

## **3. PLATFORM CONFIGURATION INFRASTRUCTURE (Lines 27-54)**

```bash
declare -A PLATFORM_ENABLED
declare -A PLATFORM_API_BASE
... (15+ associative arrays)
```

**Architecture**:
Central design pattern: **Every platform setting is an associative array**. The key is the platform name (e.g., "github"), value is the setting.

**Arrays Breakdown**:
- `PLATFORM_ENABLED`: Boolean flag from config
- `PLATFORM_API_BASE`: Root API URL (e.g., `https://api.github.com`)
- `PLATFORM_SSH_HOST`: SSH endpoint (e.g., `github.com`)
- `PLATFORM_TOKEN_VAR`: Name of env var holding token
- `_ENDPOINT`: API paths with placeholders `{owner}`, `{repo}`
- `_METHOD`: HTTP verb (GET/POST)
- `_SUCCESS_KEY`: JSON key that proves API call succeeded
- `PLATFORM_WORK_DIR`: Subdirectory name under REMOTE_ROOT
- `PLATFORM_PAYLOAD_TEMPLATE`: JSON body for repo creation (with placeholders)
- `PLATFORM_SSH_URL_TEMPLATE`: SSH URL format
- `PLATFORM_DISPLAY_FORMAT`: How to show repos in list view
- `PLATFORM_AUTH_HEADER`: Authorization header format

**Adding a Platform**: Just add a new section to `platforms.conf` and this script auto-detects it. No code changes needed.

---

## **4. PLATFORM LOADING FUNCTION (Lines 56-165)**

`load_platform_config()`

**Flow**:
1. **Check config file exists** at `$CONFIG_FILE` (defaults to `~/.config/repo-crafterFiles/platforms.conf`)
2. **Parse INI format** manually (no external dependency)
   - Detects `[section]` headers
   - Parses `key = value` pairs
   - Skips comments (`#`)
3. **Populates associative arrays** dynamically using `declare -g`
4. **Builds `AVAILABLE_PLATFORMS`** array from enabled platforms

**Critical Logic**:
- Line 112: `declare -gA "$array_name"` - Creates global associative arrays at runtime
- Lines 132-145: `case "$key" in ...)` - Routes each config key to correct array
- Lines 147-153: Filters platforms that are enabled AND have API base AND have token var

**Potential Failures**:
- **Config not found**: Script exits with helpful message showing example config
- **Syntax error**: If config line doesn't match `key = value`, it's silently skipped
- **No platforms enabled**: Returns error, script exits (prevents menu crash)

---

## **5. PLATFORM SELECTION FUNCTION (Lines 167-232)**

`select_platforms(prompt, allow_multiple)`

**Purpose**: Interactive menu for choosing platforms. Returns newline-separated list.

**Parameters**:
- `prompt`: String to display above list
- `allow_multiple`: Boolean. If true, shows `a` (All) and `m` (Multi) options

**Flow**:
1. Prints menu to `/dev/tty` (bypasses stdout capture)
2. Reads input from `/dev/tty` (ensures interactive even when piped)
3. Parses input:
   - `a` → All platforms
   - `m` → Prompts for comma-separated numbers
   - Direct number → Single platform
   - Direct comma-list → Multiple platforms (e.g., `1,3`)
4. Validates bounds (must be between 1 and platform count)
5. Returns list via `printf '%s\n' "${choices[@]}"`

**Key Design**: Returns list via stdout for command substitution:
```bash
platforms=$(select_platforms "Choose:" "true")
```

**Pitfalls**:
- **Input validation**: Invalid input returns 1, caller must handle (most do `|| return`)
- **TTY requirement**: Won't work in true non-interactive mode (but script is interactive-first)

---

## **6. TEST FUNCTION (Lines 234-275)**

`test_platform_config()`

**Purpose**: Diagnostic tool to verify setup works.
**Called by**: `--test` flag or auto-run on first launch.

**Flow**:
1. Shows loaded platforms
2. **Token check**: Iterates `AVAILABLE_PLATFORMS`, uses indirect expansion `${!token_var}` to check env vars
3. **SSH check**: Calls `check_ssh_auth()` for each platform
4. **Interactive test**: Runs `select_platforms()` to verify menu works
5. **Duplicate check**: Calls `warn_duplicate_remote_connections()`

**Auto-Skip Feature**: Creates `~/.config/repo-crafter/.no-auto-test` file if user opts out of future auto-tests.

---

## **7. CORE VALIDATION FUNCTIONS (Lines 277-389)**

### **7.1 `check_local_exists(path)`**
- **One-liner**: `[[ -d "$1/.git" ]]`
- **Purpose**: Check if directory is a Git repository
- **Used by**: Bind/unbind workflows to decide whether to `git init`

### **7.2 `check_ssh_auth(host, platform_name)`**
- **Tests SSH** with `ssh -T git@host`
- **Parses output** for success patterns (GitHub/GitLab specific)
- **Returns**: 0 if authenticated, 1 if failed
- **Critical**: Called during `--test` and before cloning

### **7.3 `is_safe_directory(target_dir)`**
- **Blacklists** `FORBIDDEN_DIRS`
- **Special check**: Explicitly blocks `/` (root directory)
- **Pattern matching**: `[[ "$target_dir" == "$dir"* ]]` checks prefixes
- **Exit on fail**: Called in `main()` before menu starts

### **7.4 `warn_duplicate_repo_name(project_name, parent_dir)`**
- **Scans** predefined search dirs (`~/Projects`, `~/Work`, etc.)
- **Finds** all `.git` directories
- **Compares** basename against `project_name`
- **Excludes** matches inside `parent_dir` (allows same name in target location)
- **Prompts** user to continue if duplicates found

### **7.5 `warn_similar_remote_repos(platform, new_name, user_name)`**
- **Fetches** user's repo list via API
- **Uses jq** to search for names containing `new_name` (case-insensitive)
- **Shows** up to 5 matches
- **Returns**: 1 if similar found (triggers warning), 0 if clear

### **7.6 `warn_duplicate_remote_connections()`**
- **Scans** both LOCAL_ROOT and REMOTE_ROOT
- **Builds** associative array mapping remote URL → list of local paths
- **Detects** when single remote is bound to multiple locals
- **Warns** about confusion risk

---

## **8. API INTERACTION FUNCTIONS (Lines 391-513)**

### **8.1 `platform_api_call(platform, endpoint, method, data)`**
**The heart of the abstraction layer.**

**Key Features**:
- **Generic auth**: Uses `PLATFORM_AUTH_HEADER` template (default: `Bearer {token}`)
- **Placeholder replacement**: `{token}` → actual token value
- **Curl args array**: Prevents shell injection
- **Timeout**: `--max-time 30` prevents hangs
- **Platform detection**: Hardcodes GitHub's `"token"` prefix vs `"Bearer"` for others

**Endpoint Template System**:
- `endpoint="${endpoint//\{owner\}/$user_name}"` - Replaces placeholders generically
- `endpoint="${endpoint//\{repo\}/$repo_name}"`
- Works for **any** platform without code changes

**Returns**: Raw JSON response

**Failure modes**:
- API base missing → exit 1
- Token missing → exit 1
- Curl fails → return code propagates (caught by caller)

---

### **8.2 `check_remote_exists(...)`**

Uses `platform_api_call` to check if repo exists.
**Success criteria**: JSON response contains `PLATFORM_REPO_CHECK_SUCCESS_KEY` (usually `"id"`)
**Returns**: 0 if exists, 1 if not, 2 if config error

---

### **8.3 `list_remote_repos(platform)`**

**Fetches** user's repositories via `PLATFORM_REPO_LIST_ENDPOINT`.
**Displays** using `PLATFORM_DISPLAY_FORMAT` template with `gsub()` for placeholders.
**Limits** to 20 results to avoid spam.

---

### **8.4 `create_remote_repo(platform, repo_name, visibility, user_name)`**

**Most complex function** - creates remote repository.

**Steps**:
1. **Get template** from `PLATFORM_PAYLOAD_TEMPLATE`
2. **Replace placeholders**: `{repo}`, `{owner}`, `{private}`, `{visibility}`
3. **Remove leftover placeholders** (for platforms that don't use them)
4. **Call API**: POST to `PLATFORM_REPO_CREATE_ENDPOINT`
5. **Check success**: Looks for `PLATFORM_REPO_CHECK_SUCCESS_KEY` in response
6. **Extract SSH URL**: First tries JSON fields, then falls back to template generation

**Template Fallback Logic**:
```bash
ssh_url=$(echo "$response" | jq -r '.ssh_url // .ssh_url_to_repo // .clone_url // empty')
if [[ -z "$ssh_url" ]]; then
  ssh_template="${PLATFORM_SSH_URL_TEMPLATE[$platform]:-git@{ssh_host}:{owner}/{repo}.git}"
  # ... replace placeholders ...
fi
```

**UX**: Shows "Creating..." progress, returns SSH URL or error.

---

## **9. WORKFLOW FUNCTIONS (Lines 515-789)**

### **9.1 `create_new_project_workflow()`**
**Main entry point for creation sub-menu**.
Shows options: New remote, Clone, Local-only.
No logic - just dispatches to `_create_*` helpers.

---

### **9.2 `_create_with_new_remote()`**

**Core creation logic** (longest function).

**Flow**:
1. **Name prompt**: Validates `[a-zA-Z0-9_-]+` regex
2. **Platform selection**: Calls `select_platforms`
3. **Directory logic**: Single platform → `github.com/project/`; Multi → `Multi-server/project/`
4. **Safety checks**: `warn_duplicate_repo_name`, `warn_similar_remote_repos`
5. **Visibility prompt**: Private/Public
6. **Local creation**: `mkdir`, `git init`, `README.md`
7. **Gitignore**: Calls `gitignore_maker`
8. **Remote creation**: Loop through platforms → `create_remote_repo`
9. **Git operations**: `git remote add`, `git add`, `git commit`, `git push`
10. **Multi-platform manifest**: Creates `PLATFORMS.md` if >1 platform
11. **`cd -`**: Returns to original directory

**Key Lines**:
- `gitignore_strategy=$(gitignore_maker ...)` - Captures return value (normal vs exclude)
- `if [[ "$gitignore_strategy" == "exclude" ]]` - Handles Mode 3 logic
- `git add :/ 2>/dev/null || git add .` - Adds everything except .gitignore (Mode 3)

---

### **9.3 `_clone_existing_remote()`**

**Simple wrapper** around `git clone`.
**Warning note**: Reminds about org repo format
**SSH check**: Verifies auth before attempting clone

---

### **9.4 `_create_local_only()`**

**Minimal logic**: `mkdir`, `git init`, `README.md`, done.
**Notable**: Explicitly tells user it's "Unbound" (reminder to bind later)

---

### **9.5 `convert_local_to_remote_workflow()`**

**Moves local project to remote-bound**.

**Steps**:
1. **Select project**: From `Local_Projects`
2. **Select platforms**: Multi-platform supported
3. **Directory calculation**: Same logic as creation
4. **Move operation**: `execute_dangerous mv` (preview if dry-run)
5. **Git init if needed**: In case it was just a folder
6. **Add remotes**: Loop through platforms, generate SSH URLs
7. **Multi-platform manifest**: If >1 platform

**Key**: `project_name=$(basename "$source_dir")` extracts name after selection

---

### **9.6 `convert_remote_to_local_workflow()`**

**Inverse of above**.

**Steps**:
1. **Select from Remote_Projects**
2. **Confirm warning**: Shows what will be removed
3. **Remove remotes**: Loop through `git remote` output
4. **Delete PLATFORMS.md** if exists
5. **Move to Local_Projects**: `execute_dangerous mv`

---

### **9.7 `list_remote_repos_workflow()`**

**Simple dispatcher**:
- Selects platform(s)
- Calls `list_remote_repos()` for each
- Formats output with headers

---

### **9.8 `manage_project_workflow()`**

**Deletion sub-menu**.

**Options**:
- `1) Delete local copy` → `_delete_local_copy`
- `2) Unbind...` → Reuses `convert_remote_to_local_workflow`
- `3) Delete BOTH` → `_delete_both` (most dangerous)

---

### **9.9 `_delete_local_copy()`**

**Deletes directory only**.
**Confirmation**: Standard y/N prompt
**No remote impact**: Safe operation

---

### **9.10 `_delete_both()`**

**Most dangerous function**.

**Safeguards**:
1. **Select project** from Remote_Projects
2. **Type project name exactly** to confirm (prevents accidents)
3. **Deletes remote API**: `DELETE /repos/user/name`
4. **Deletes local**: `rm -rf`

**No recovery**: Remote deletion is permanent.

---

## **10. GITIGNORE WORKFLOW (Lines 791-917)**

### **10.1 `gitignore_maker(project_dir, mode)`**

**Three modes**:
- **Mode 1 (Simple)**: Create .gitignore, commit immediately
- **Mode 2 (Cautious)**: Create .gitignore, open in nano, then commit
- **Mode 3 (Local-only)**: Moves to `.git/info/exclude`, never committed

**Key Logic**:
- **Detection**: `detect_project_types()` returns "node", "python", etc.
- **Auto-patterns**: Hardcoded common patterns (node_modules/, .env, etc.)
- **Manual entry**: Prompts for additional patterns line-by-line
- **Templates**: For existing files, can create `.example` templates

**Mode 3 Magic**:
```bash
mv "$ignore_file" "$project_dir/.git/info/exclude"
echo "exclude"  # Signal to caller
```

**DRY-RUN Handling**: Entire function reimplemented to simulate without touching filesystem.

---

## **11. UTILITY HELPERS (Lines 919-1018)**

### **11.1 `_pause_if_dry_run()`**
- **Called after every workflow** in dry-run mode
- **Gives user time** to read output before screen clears

### **11.2 `gitignore_maker_interactive()`**
- **Entry point for standalone gitignore mode** (menu option 6)
- **Prompts for directory**, then calls `gitignore_maker`

### **11.3 `_select_and_template_files()`**
- **Interactive pattern entry** loop
- **Template creation**: For existing files, asks to create `.example`
- **Sed replacement**: `s/=.*/=YOUR_VALUE_HERE/` sanitizes secrets in examples

### **11.4 `_prompt_project_name()`**
- **Validation loop**: Regex `[a-zA-Z0-9_-]+`
- **Retries**: On invalid input, shows error and loops

### **11.5 `_prompt_visibility()`**
- **Simple choice**: 1=private, 2=public
- **Validation**: Loops on invalid input

### **11.6 `_select_project_from_dir()`**
**Critical helper for conversion/deletion**.

**Features**:
- **Lists projects** with size and current branch
- **Bounds checking**: Validates numeric input
- **Git status**: Shows `(Git)` or `(No repo)`
- **DU integration**: Shows human-readable size

**Format**: `1) project-name [2.1M] (main)`

---

## **12. CONFIRMATION UX (Lines 1020-1042)**

`confirm_action(message, default)`

**Standardized confirmation**:
- **Default to "n"** for dangerous actions
- **Default to "y"** for safe actions
- **Regex**: `[[ $REPLY =~ ^[Yy]$ ]]` for yes, `[[ ! $REPLY =~ ^[Nn]$ ]]` for yes-by-default

**Used by**: Deletion, overwriting, optional SSH test

---

## **13. EXECUTION HELPERS (Lines 1044-1074)**

### **13.1 `execute_dangerous(description, command, ...)`**

**Core safety mechanism**.

**DRY-RUN mode**:
- Prints yellow box border
- Prints `[DRY RUN] description`
- Prints quoted command
- **Returns 0** (simulates success)

**Normal mode**:
- Prints `[PREVIEW] description`
- Prints quoted command
- **Prompts**: "Execute? (y/N)"
- **Executes** if `y`, returns 1 if `n`

**Key Design**: Uses `"$@"` to preserve arguments, includes `printf '%q '` for shell-escaped display

### **13.2 `execute_safe(description, command, ...)`**

**Silent in normal mode, verbose in dry-run**.

**Used for**: `mkdir`, `git add`, `git commit` (operations that are safe or already confirmed)

---

## **14. MAIN MENU (Lines 1076-1115)**

`main_menu()`

**Infinite loop**: `while true; do ... done`

**UX Features**:
- **Clear screen**: `clear` on each iteration
- **Header**: ASCII art with version
- **Status bar**: Shows loaded platforms and root path
- **Grouped options**: Create, Manage, Remote, System
- **Input**: Single key press (1-8)
- **Invalid handling**: Shows error, sleeps 1 second, loops

**Dispatch**: Simple `case` statement calls workflow functions

**Exit**: Option 8 or Ctrl+C (trapped by `set -e`, but safe due to loop structure)

---

## **15. DRY-RUN & ARGUMENT PARSING (Lines 1117-1135)**

`parse_args()`

**Global flag**: `DRY_RUN=false` (set to `true` by `--dry-run`)

**Arguments**:
- `--dry-run` / `-n`: Sets flag, prints header
- `--test` / `-t`: Runs `load_platform_config` and `test_platform_config`, then **exits**
- `--help` / `-h`: Shows usage, exits

**Position**: Called at script start, before `main()`

---

## **16. MAIN INITIALIZATION (Lines 1137-1196)**

`main()`

**Validation sequence** (must happen in this order):

1. **Tool check**: Loops `git curl jq ssh`, exits if missing
2. **Load config**: `load_platform_config()` - Exits if fails
3. **Config test**: **NEW** - Interactive prompt to run `--test` (can skip)
4. **Safety check**: `is_safe_directory "$(pwd)"` - Exits if in forbidden dir
5. **Status display**: Shows platform token status (✓/✗)
6. **Launch menu**: `main_menu()` (enters infinite loop)

**Critical Dependencies**:
- `load_platform_config` must succeed before any workflow
- `DRY_RUN` flag must be parsed before `main_menu` (so workflows see it)
- Tool check must happen before any workflow attempts to use them

---

## **17. SCRIPT EXECUTION GUARD (Lines 1198-1200)**

```bash
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

**Purpose**: Only runs `main()` if script is executed directly (not sourced).
**Allows**: Sourcing script in other scripts without side effects.

---

## **DEBUGGING GUIDE**

### **If script exits with no error message**:
Check `set -e` triggered. Run with `bash -x repo-crafter.sh` to trace.

### **If "Token NOT set" but you set it**:
- Token variable name in `platforms.conf` must match env var name exactly
- Run `echo $GITHUB_API_TOKEN` in same terminal
- Check for typos in export statement

### **If SSH fails during test**:
- Run `ssh -T git@github.com` manually
- Check key permissions: `chmod 600 ~/.ssh/id_*`
- Verify key added to platform's web UI

### **If API call fails**:
- Check `PLATFORM_API_BASE` in config
- Use `--test` to see full error
- Check token scopes (need `repo` for GitHub, `api` for GitLab)

### **If project creation fails**:
- Check `PLATFORM_PAYLOAD_TEMPLATE` matches platform's API docs
- Check `PLATFORM_REPO_CREATE_ENDPOINT` path
- Look at `PLATFORM_REPO_CHECK_SUCCESS_KEY` (some platforms use `"id"`, others `"name"`)

---

## **REFACTORING NOTES**

**To add a new workflow**:
1. Create function `my_workflow()`
2. Add menu option in `main_menu()` case statement
3. Follow pattern: Use `select_platforms()` if needed, then `execute_dangerous` for operations

**To add a new platform setting**:
1. Add `declare -A PLATFORM_NEW_SETTING` to globals
2. Add to reset loop in `load_platform_config()`
3. Add parsing case in config parser
4. Use in appropriate function

**To change project root**:
Modify `LOCAL_ROOT` and `REMOTE_ROOT` at top of script. **Manually move existing projects** to new locations.

**To disable dry-run**:
Remove `DRY_RUN` checks in `execute_dangerous` and `execute_safe`, or set `DRY_RUN=false` permanently.

---

**End of Documentation**
